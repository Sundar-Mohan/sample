Returning 2 tags in render method,
use the div -> it leads to extra div.
So use <React.Fragment>

Set the properties:
State={
count:1;
};

If we wants to get the count value -> this.state.count
Also we can do like this to avoid repetation, const {count} = this.state;

We can set the dynamic data in render method -> using {}
{} -> it should contains some value, we can also call the function that should return the value.

How to set the attributes:
<img scr={this.state.} alt=""/>
To change the text like batch -> use the className = "badge badge-primary"
className = "badge badge-primary m-2"(margin 2)

Bootstrap install: 
npm i bootstrap@4.1.1
then import in index.js -> import 'bootstrap/dist/css/bootstrap.css'

styles={
fontSize:50;
fontWeight:"bold"
};
<span style{this.style}></span>
or
<span style{{fontSize:50}}></span>

when we are modifying the const value, need to use let instead of const.
render(){
let classes = "badge m-2 badge-";
classes += this.state.count ===0? "warning" : "primary";
}
(use refractor by right click, to move the above lines in separate method)
we can also set the className dynamically. className={classes}

Rendering list of items:
state={
tags:["tag1","tag2","tag3"]
};

<ul>{this.state.tags.map(tag=> <li>{tag}</li>)}</ul>   ---------unique key error
<ul>{this.state.tags.map(tag=> <li key={tag}>{tag}</li>)}</ul>


Button onClick={}


If the function is part of the obj, "this" references the obj itself.
If the function is not part of the onj, "this" refers to the global obj in node, window obj in browsers.

Eg:1
const video={   //this the video obj created
title:'a',
play(){
 console.log(this); // it refers the current obj
}
};
video.stop=function(){   // creating the stop method in video obj
console.log(this);       // this refers the current obj.
}
video.play();

Eg:2
//individual function
function play(){
console.log(this);    //this return the window obj.
}

Eg:3
//Regular function
function play(game){
this.game = game;
console.log(this);    //now this return the play obj.
}
const v = new play('cricket'); //when we are using new , it creates the empty obj like {}, then it sets {this.game}

Eg:4
const video={
title:'a',
tags:['a','b','c'],
showTags(){
 this.tags.forEach(function(tag){
  console.log(this.title,tag);      //here this refers the window obj, because this is used in the regular function not in showTags method
});
}
};
video.showTags();

Eg:5
const video={
title:'a',
tags:['a','b','c'],
showTags(){
 this.tags.forEach(function(tag){
  console.log(this,tag);      // this points the regular function, contains {firstname:"sundar"}
}, {firstname:"sundar"});   
}
};
video.showTags();

Eg:6
const video={
title:'a',
tags:['a','b','c'],
showTags(){
 this.tags.forEach(function(tag){
  console.log(this.title,tag);      
}, this);                           // now "this" is inside the showTags() method, now this.title points to video obj
}
};
video.showTags();


__________________________________

Binding the obj to regular methods:
 
Clas Counter ...{
state={
count:0
};
constructor(){
 super();
 this.handleIncrement = this.handlerIncrement.bind(this); //here Counter obj assigned to regular function handleIncrement()
}
handleIncrement(){
  console.log("Increment clicked", this);
}
render(){
return(
<button onClick={this.handleIncrement}>Increment</button>
)}
}

Problem for the above code, for event event handler need to write the bind .
So, using arrow function, it will inherits the this.
handleIncrement = () => {                        // no need the constructor for binding "this"
 console.log("Increment Clicked", this);
}

Changing the count value:
handleIncrement = () => {                        
 this.setState({ count : this.state.count +1});  // setState is the method of Component class
}


Passing Event Arguments:

doeventhandler = () =>{
  this.handleIncrement({id:1});
};
handleIncrement = product => {
console.log(product);            //it returns {id:1}
}
onClick ={this.doeventhandler}

Now we can simplify the above code as,
onClick={() => this.handleIncrement(product)}


this.props -> display the current component arguments
state={
count: this.props.value   //gets the attribute from the current class from <Counter value=>
}

Props vs State

Props : data that gives to the component, it can't be modified but possible through state{}
State : data that local or private to the component(Counter), other components can't access this state

DANGER button - btn btn-danger btn-sm m-2
onClick = {this.props.onDelete}    //deleting the count



































